\documentclass[12pt, a4paper, oneside, chapter=TITLE, section=title, subsubsection=title, english, brazil, font=plain]{abntex2}

\usepackage{parskip}			% espaçamento entre os parágrafos
\usepackage{microtype} 			% para melhorias de justificação
\usepackage{morefloats}			% permite mais floats

\usepackage{Alegreya,AlegreyaSans} 
%\usepackage{lmodern}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{geometry}
\usepackage{fancyvrb}
\usepackage{fvextra}
%\usepackage{listings}
\usepackage{hyperref}
\usepackage{subfig}
\usepackage{tabularx,array,colortbl}
\usepackage{rotating}
\usepackage{multirow}
\usepackage[table]{xcolor}
\usepackage[alf]{abntex2cite}
\usepackage{graphicx}
\geometry{tmargin= 3cm,bmargin= 1.5cm,lmargin= 3cm,rmargin=2.5cm}
%\chapterstyle{reparticle}
%\renewcommand{\ABNTEXchapterfont}{\bfseries}
%\renewcommand{\ABNTEXchapterfontsize}{\normalsize}
%\renewcommand{\ABNTEXsectionfontsize}{\normalsize} 
%\renewcommand{\ABNTEXsectionfont}{\bfseries} 
%\renewcommand{\ABNTEXsubsectionfontsize}{\normalsize}
%\renewcommand{\ABNTEXsubsectionfont}{\normalsize}
%\renewcommand{\ABNTEXsubsubsectionfontsize}{\normalsize}
%\renewcommand{\ABNTEXsubsubsectionfont}{\bfseries}

% CONFIGURACAO DO SUMARIO
% -----------------------------------------------------------------------------
% Modifica o espaçamento no sumário
% Nao ha espacos, exceto para as entradas de capitulos

% \renewcommand{\tocheadstart}{\ABNTEXchapterfont}
\renewcommand{\tocheadstart}{\normalfont}
\setlength{\cftbeforeparagraphskip}{0pt}
\setlength{\cftbeforesubsectionskip}{0pt}
\setlength{\cftbeforesectionskip}{0pt}
\setlength{\cftbeforesubsubsectionskip}{0pt}
\setlength{\cftbeforechapterskip}{\onelineskip}
% \renewcommand*{\cftsubsectionfont}{\itshape}
% \renewcommand*{\cftchapterpagefont}{\normalfont}
% \renewcommand*{\cftsectionfont}{\normalfont}

% Modifica a formatacao dos textos
\renewcommand{\chaptitlefont}{\normalfont\bfseries}
\setsecheadstyle{\normalfont\bfseries}
\setsubsecheadstyle{\normalfont\bfseries}
\setsubsubsecheadstyle{\normalfont\bfseries}
% Secao secundaria (Section) Caixa baixa, Negrito, tamanho 12
\renewcommand{\cftsectionfont}{\bfseries} %ponha \rmfamily se quiser serifadas...
% Secao terciaria (Subsection) Caixa baixa, italico, tamanho 12
\renewcommand{\cftsubsectionfont}{\itshape}
% Secao quaternaria (Subsubsection) Caixa baixa, Negrito, sublinhado, tamanho 12
\renewcommand{\cftsubsubsectionfont}{\itshape\bfseries}
% Seção quinaria (subsubsubsection) Caixa baixa, sem negrito, tamanho 12
\renewcommand{\cftparagraphfont}{\normalfont}

\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}}

\counterwithout{footnote}{chapter}
\counterwithout{equation}{chapter}
\setlength\afterchapskip{\lineskip}
\hypersetup{bookmarks=true}

\autor{}
\instituicao{ }
\titulo{}
\local{}
\data{}

%\comentario{}
\makeatletter
%\@removefromreset{footnote}{chapter}
\makeatother

\begin{document}
%\selectlanguage{brazil}
%\frenchspacing 

%\imprimircapa
%\imprimirfolhaderosto
%\sumario

% ---
% inserir o sumario
% ---
%\pdfbookmark[0]{\contentsname}{toc}
\tableofcontents*
\cleardoublepage
% ---

% ----------------------------------------------------------
% ELEMENTOS TEXTUAIS
% ----------------------------------------------------------
\textual
%\setcounter{page}{2}


\begingroup
\let\clearpage\relax

\chapter{Início}
\vspace{\baselineskip}

Esta documentação faz referência aos repositórios: \textbf{srcLCB} e \textbf{srcsib2model}. O repositório é composto de códigos utilitários para o LCB/IAG/USP, enquanto o \textbf{srcsib2model} concentra apenas o código fonte do modelo SiB2 \cite{sellers1996I,sellers1996II} e suas respectivas modificações. 

A versão mais atual do modelo SiB2 está no repositório \textbf{srcsib2model},
diretório ``SiB2f95modvars'', em que, o SiB2 está traduzido para Fortran 95 e as variáveis do comsibc e pardif operam como um módulo de Fortran.

Para compilar o SiB2:
\begin{Verbatim}[breaklines=true]
gfortran comsibc.f95 pardif.f95 sib2x.f95 Sib2xa.f95 Sib2xb.f95 -o sib2run
\end{Verbatim}

Para executar:
\begin{Verbatim}[breaklines=true]
./sib2run
\end{Verbatim}
no diretório em que se encontra os arquivos ``data1'' e ``data2''.

O código do SiB2 que se trabalhava no LCB em Fortran 77
está no repositório \textbf{srcsib2model}, diretório ``SiB2f77''.

% O SiB2 também foi convertido em um módulo de Python no diretório ``SiB2pymod'' do \textbf{srcsib2model}, principalmente para servir ao conjunto numérico de otimização de parâmetros do SiB2 desenvolvido em Python. 

\vspace{\baselineskip}

\chapter{Descrição e melhorias do SiB2 do LCB}
\section{Formato dos dados ambientais de entrada: arquivo data2}

São sete colunas de dados, sendo, da esquerda para direita:\\

\noindent
1\textsuperscript{a} -- datetime: ano, mês, dia e hora YYMMDDHH \\
2\textsuperscript{a} -- Ki(Wm\^{$-2$}): irradiância de onda curta incidente observada [Wm$^{-2}$]\\
3\textsuperscript{a} -- em(hPa): pressão de vapor d'água observada [hPa]\\
4\textsuperscript{a} -- tm(K): temperatura do ar observada [K]\\
5\textsuperscript{a} -- um(ms\^{$-1$}): velocidade horizontal do vento observada [ms$^{-1}$]\\
6\textsuperscript{a} -- prec(mm): precipitação observada [mm]\\
7\textsuperscript{a} -- Rn(Wm\^{$-2$}): saldo de radiação observado [Wm$^{-2}$]\\

O formato explícito em fortran é ``(A8,6F11.4)'', exemplo:

\begin{verbatim}
write(2,'(A8,6F11.4)') nymd, swdown, em, tm, um, prec, rnetm
\end{verbatim}

Os arquivos ``data2'' são gerados pelo programa em Fortran 95 denominado
como ``data2\_format.f95'' localizado no diretório ``utils'' do
repositório \textbf{srcLCB}. Inicialmente Rn ficava na 3\textsuperscript{a} coluna, mas em agosto de 2019, a ordem das colunas foi alterada para permitir a inserção de uma condição ``if'' no código que seleciona o flag ``ilw'' e decide sobre o uso da coluna de Rn. 

\section{Equação rsoil no Sib2xb}
\vspace{\baselineskip}

O LCB vem utilizando 2 equações para rsoil:

\begin{equation}
  rsoil =  amax1 (0.1, 694. - fac*1500.) + 23.6
\label{default}
\end{equation}

\begin{equation}
  rsoil =  amax1 (0.1, 1001. - exp(fac*6.686))
\label{cinthiacerrado}
\end{equation}

A tabela abaixo indica qual a equação rsoil tem sido utilizada para cada local de medidas.

\begin{table}[ht]
  \centering
  \caption{Equação rsoil utilizada em cada sítio de medidas}
  \begin{tabular}{l c}
    \hline 
    \hline 
  Locais & equação \\
    \hline 
  Cana & \ref{cinthiacerrado}\\
  Cerrado & \ref{cinthiacerrado}\\
  Eucalipto & \ref{default}\\
  Fazenda K77 & \ref{cinthiacerrado}\\ 
  Floresta Atlântica & \ref{default}\\
  Floresta Rondônia & \ref{cinthiacerrado}\\
  Pastagem Rondônia & \ref{cinthiacerrado}\\
  Pastagem SP & \ref{cinthiacerrado}\\
    \hline
  \end{tabular}
\end{table}
\vspace{\baselineskip}

\section{Compilando o SiB2 no gcc e a tradução do Fortran 77 para Fortran 95}

Identificou-se que o modelo SiB2 que vinha sendo utilizado no LCB, escrito em Fortran 77, apresentava erros de compilação e de execução quando compilado a partir do gfortran no linux debian buster e versões anteriores mesmo usando o g77 que integrava o gcc até a sua versão 3.4.6. O SiB2 no LCB geralmente era utilizado a partir de compiladores de Fortran 77 em sistema windows que já não estão mais disponíveis no LCB, portanto, foram estudadas as possibilidades de continuar fazendo altereções no SiB2 usando compiladores de Fortran mais portáveis e nas versões mais atuais e neste sentido o gfortran que integra o gcc 8.3.0 foi considerado o mais apropriado.

Fazendo modificações no código do SiB2 em Fortran 77, combinadas com os flags de compilação ``-fno-automatic'' e ``-finit-local-zero'' disponíveis no gfortran, os erros de compilação e execução do SiB2 do LCB no gfortran do gcc 8.3.0 foram solucionados e os resultados das saídas do modelo compilado no gfortran e nos compiladores para windows ficaram iguais, apresentando pequenas diferenças provavelmente associadas com arredondamento numérico, conforme mostra a figura \ref{checkvars}.

\begin{figure}[ht]
\centering 
\includegraphics[width=\textwidth]{img/09SiB2varC}
\caption{Comparação entre H calculado com o SiB2 compilado no windows e compilado no gfortran com os flags ``-fno-automatic'' e ``-finit-local-zero''. Em cada coluna deste painel (da esquerda para direita) está a dispersão, o desvio no tempo de H windows~-~gfortran e H no tempo, sendo H na cor branca~=~windows e H na cor vermelha~=~gfortran, sendo possível ver apenas a sobreposição da cor vermelha. Em cada linha (de cima para baixo) temos a série temporal horária, as médias diárias e mensais.}
\label{checkvars}
\end{figure}

Com o código em IDL \textbf{srcLCB}/plots/x\_plot\_checkdefault.pro é possível gerar o
painel da figura \ref{checkvars} para todas as variáveis do SiB2.

Após esta etapa de compilação e execução do SiB2 em Fortran 77, o
código do SiB2 do LCB foi traduzido integralmente para o Fortran 95 em \textbf{srcsib2model}/SiB2f95.  

\section{SiB2 em Fortran 95: comsibc.h e pardif.h como módulo de variáveis}
\label{f95}

Após a tradução do SiB2 de Fortran 77 para 95, foi desenvolvida uma
versão do código, em \textbf{srcsib2model}/SiB2f95modvars, que elimina as
declarações de variáveis do tipo "common" e cria módulos de variáveis
de Fortran: o  comsibc.f95 e o pardif.f95. Nesta versão deve-se compilar o código conforme os seguintes comandos:

\begin{Verbatim}[breaklines=true]
gfortran comsibc.f95 pardif.f95 sib2x.f95 Sib2xa.f95 Sib2xb.f95 -o sib2run
\end{Verbatim}

Além dos módulos de variáveis, acrescentou-se ``implicit none'' no
programa e em todas as sub-rotinas declarando todas as variáveis
explicitamente.

Nesta etapa, foi revisada a necessidade do uso dos
flags de compilação -- ``-fno-automatic -finit-local-zero'' -- que
inicializa todas as variáveis com valor zero e declara todas as
variáveis como ``save''.

Usando o flag de compilação ``-Wall'', o gfortran indicou as variáveis
que integravam os cálculos do SiB2 e que deveriam inicializar com
valores, pois estavam sendo inicializadas com valores qualquer
alocados na memória na hora da declaração de variáveis. Estas
variáveis identificadas foram:

\begin{Verbatim}[breaklines=true]
  sib2x: ptot

  Sib2xa: zinc
        : us1

  Sib2xb: cs
        : th
        : qm
        : wmin
\end{Verbatim}

Declarando estas variáveis com valores iniciais igual a zero (e isso
está feito em \textbf{srcsib2model}/SiB2f95modvars) exclui-se a
necessidade do uso dos flags de compilação ``-fno-automatic
-finit-local-zero'', pois assim os resultados
dos cálculos são idênticos aos valores calculados quando
compila-se o SiB2 com os flags ``-fno-automatic -finit-local-zero''
e coincidem com os cálculos do SiB2 em Fortran 77 compilado no
windows, como mostrado na figura \ref{checkvars}. No entanto, sugiro uma
verificação destas variáveis a respeito de quais os valores elas devem
ter inicialmente no código, se existe alguma que o seu valor deve ser diferente de zero.

\section{SiB2pymod}

O SiB2pymod é o modelo SiB2 em Fortran 95, compilado como um módulo de python 
3 com o uso do f2py do integra o numpy. Para isso, uma pequena mudança
no código do SiB2 é feita. O programa sib2 é descrito como
uma sub-rotina. Desta forma o sib2 é usado como uma função python.

Para gerar o sib2pymod execute:
\begin{Verbatim}[breaklines=true]
f2py3.7 --fcompiler=gnu95 -c comsibc.f95 pardif.f95 sib2x.f95 Sib2xa.f95 Sib2xb.f95 -m sib2pymod
\end{Verbatim}

\subsection{Herança de valores e warm-up do modelo}

Observou-se que as variáveis do SiB2 quando carregadas via python 
\begin{Verbatim}[breaklines=true]
import sib2pymod
resultado = sib2pymod.sib2()
\end{Verbatim}
não são declaradas novamente a cada solicitação da função
``sib2()''. As variáveis são declaradas apenas uma vez na
importação. A cada execução da função ``sib2()'', as variáveis do SiB2
iniciam com os valores que ficaram na memória referente a rodada
anterior.

Na figura \ref{rn1rn2} observe as pequenas diferenças entre os valores
de Rn para uma primeira execução da função ``sib2()'' e uma segunda
execução da função ``sib2()''. 
\begin{figure}[ht]
\centering 
\includegraphics[width=0.7\textwidth]{img/rn1rn2sib2pymod}
\caption{Comparação entre o cálculo de Rn para a primeira execução da  função python ``sib2()'' (Rn1) e na segunda execução da função python ``sib2()'' (Rn2) em um programa python. De cima para baixo, é mostrado a dispersão, desvio e ampliação do desvio.}
\label{rn1rn2}
\end{figure}

Observe que devido os valores iniciais de alguma ou algumas variáveis
serem diferentes, existem um pequeno desvio nos valores iniciais e que
se estabilizam no decorrer dos cálculos, principalmente nos 30
primeiros passos de tempo.

Na segunda execução, pode ocorrer algo igual eu cito em \ref{f95}, em que variáveis que deveriam ser inicializadas com determinados valores no primeiro passo de tempo do SiB2 não estão sendo inicializadas, como é o caso da variável itero, que deve ser = 0 no início dos cálculos, e a cada execução da função ``sib2()''.

Quando o SiB2 offline é executado na linha de comando apenas uma vez, não se observa  problemas de herança de valores da rodada anterior. Agora na execução do SiB2 como um módulo de python, o problema de herança de valores da rodada anterior pode ser notado como mostra a figura \ref{rn1rn2}.

Também deve-se considerar o \textit{warm-up} do modelo SiB2 em rodadas consecutivas dentro do python. Variáveis com temperatura do solo e umidade do solo, possuem uma persistência maior no tempo do que as demais variáveis. Se o modelo inicia-se em um período úmido, mas a sua rodada anterior no ambiente python terminou em um período seco, os valores iniciais terão um efeito de \textit{warm-up}.  
%\vspace{\baselineskip}
\section{Calibração do SiB2: uso de método de otimização de parâmetros
do modelo.}
%\vspace{\baselineskip}

O SiB2pymod foi criado especialmente para ser acoplado em um instrumento numérico de otimização de parâmetros que integra o ambiente Python, o LMFIT \cite{lmfit}.

A calibração do SiB2 é realizada em 4 módulos:

\begin{itemize}
\item Módulo de radiação
\item Módulo de momentum
\item Módulo de umidade do solo
\item Módulo de carbono e água
\end{itemize}

O processo de otimização de parâmetros consiste basicamente na definição de uma função que determina um erro a ser minimizado. Diferentes métodos numéricos de minimização de erro podem ser utilizado, no entanto, aqui utiliza-se o método ``brute'' que calcula todas as possibilidades diante grade de prarâmetros pré definida e o método ``leastqr'' que consiste no método de Levenberg-Marquardt. 

Foi desenvolvido um SiB2pymod para cada módulo de calibração que se encontram em \textbf{srcsib2model}/SiB2pymod/. As rotinas para a calibração, que usam cada respectivo SiB2pymod estão em \textbf{srcLCB}/calibracaoSiB2/.

É importante sempre verificar os valores do ``modeloerro'' da função ``residualSiB2''. Erros enormes, principalmente associados a valores inválidos (-9999.) comprometem todo o processo de otimização de parâmetros.

Mais detalhes a respeito dos métodos minimização de erro da classe ``Minimizer'' do LMFIT e a respeito da definição do ``modeloerro'' por meio de uma função residual, aqui denominada como ``residualSiB2'', podem ser consultadas em \url{https://lmfit.github.io/lmfit-py/}

\vspace{\baselineskip}
\section{Cálculo do conjunto de parâmetros aerodinâmicos a cada passo
  de tempo: acoplamento da derive\_trans do DBHM no SiB2.}
\vspace{\baselineskip}



\vspace{\baselineskip}
\section{Tradução do SiB2 para linguagem C com f2c}
\vspace{\baselineskip}

Pode ser conveniente traduzir o SiB2 do Fortan 77 para linguagem C e
para isto pode-se utilizar o f2c (http://www.netlib.org/f2c/). Este
processo tem se mostrado eficiente, evitando incompatibilidades de
compiladores mais antigos de fortran para os mais atuais. Desta forma
obtém-se o código em C e compila-se com o um compilador de C, gerando um binário executável independente de um compilador de Fortan.

Inicialmente os arquivos .for devem ser renomeados para .F. Após execute.

\begin{Verbatim}[breaklines=true]
f2c -Nn802 *.F
\end{Verbatim}

Desta forma obtém-se os códigos fontes em C: sib2x.c, Sib2xa.c e Sib2xb.c. Para obter o executável, aqui nomeado com SiB2runF2C, execute.  

\begin{Verbatim}[breaklines=true]
gcc -c -o sib2x.o sib2x.c
gcc -c -o Sib2xa.o Sib2xa.c
gcc -c -o Sib2xb.o Sib2xb.c
gcc -o SiB2runF2C sib2x.o Sib2xa.o Sib2xb.o -lf2c -lm
\end{Verbatim}

Este mesmo resultado obtém utilizando o script fort77 em perl que pode ser obtido pelo pacote ``fort77 - Invoke f2c like a real compiler'' do debian.

\vspace{\baselineskip}
\chapter{Processos de Calibração do SiB2}
\vspace{\baselineskip}

A calibração do SiB2 obedece uma sequência de etapas que inicia em executar o SiB2 com os parâmetros determinados sem calibração, execução do instrumento numérico de calibração para cada módulo determinando-se o conjunto de parâmetros ótimos para cada módulo, de forma que, os parâmetros calibrados no módulo anterior sejam incorporados para a calibração do módulo subsequente.

A sequência modular de calibração deve ser:
\begin{enumerate}
\item Módulo de radiação
\item Módulo de momentum
\item Módulo de umidade do solo
\item Módulo de carbono e água
\end{enumerate}

Cada módulo de calibração do SiB2, consiste em uma versão do código do SiB2 em Fortan 95, modificada conforme a necessidade de cada módulo e compilada como uma função de Python 3. 

Após a calibração de todos os parâmetros, executa-se o SiB2 para comparação dos resultados com a execução inicial do SiB2 sem calibração.

\section{Execução do SiB2 sem calibração}

\begin{enumerate}
\item Obtenha os arquivos de entrada do SiB2: arquivo ``data2'' e o arquivo ``data1''.
\item Obtenha o código do SiB2 em \textbf{srcsib2model}/SiB2f95modvars, compile e gere o executável.
\begin{Verbatim}[breaklines=true]
gfortran comsibc.f95 pardif.f95 sib2x.f95 Sib2xa.f95 Sib2xb.f95 -o sib2run
\end{Verbatim}

\item Execute
\begin{Verbatim}[breaklines=true]
./sib2run
\end{Verbatim}
no diretório em que se encontra os arquivos ``data1'' e ``data2''.
\item Observe que o arquivo ``sib2dt.dat'' com as variáveis calculadas do SiB2 foi criado.
\end{enumerate}

\section{Calibração do Módulo de Radiação}

\begin{enumerate}
\item Obtenha o código do módulo de radiação em \textbf{srcsib2model}/SiB2pymod/RadiativeTransModule. 
\item  Compile e gere o módulo de Python
\begin{Verbatim}[breaklines=true]
f2py3.7 --fcompiler=gnu95 -c *.f95 -m sib2pymod
\end{Verbatim}
observe que um arquivo com nome similar à ``sib2pymod.cpython-37m-x86\_64-linux-gnu.so'' deve ser gerado, que é o módulo de Python 3. 

\item Obtenha os arquivos de entrada do SiB2: arquivo ``data2'' e o arquivo ``data1''.

\item Obtenha o arquivo ``data3.csv'' com os dados observados que serão comparados com os valores calculados pelo SiB2 no processo de otimização de parâmetros. 

\item Obtenha o programa ``calibraSiB2\_leastsq.py'' para uso do método \textit{Levenberg-Marquardt} ou ``calibraSiB2\_brute.py'' para uso do método \textit{brute} em \textbf{srcLCB}/calibracaoSiB2/radiation.
  
\item Execute o programa ``calibraSiB2\_leastsq.py''
\begin{Verbatim}[breaklines=true]
python3.7 calibraSiB2_leastsq.py
\end{Verbatim}
ou o programa ``calibraSiB2\_brute.py''.
\begin{Verbatim}[breaklines=true]
python3.7 calibraSiB2_brute.py
\end{Verbatim}
  
\item Observe que a saída deve ter a seguinte forma:

\begin{Verbatim}[breaklines=true]
[[Fit Statistics]]
    # fitting method   = leastsq
    # function evals   = 46
    # data points      = 726
    # variables        = 4
    chi-square         = 4484619.38
    reduced chi-square = 6211.38418
    Akaike info crit   = 6344.97389
    Bayesian info crit = 6363.32409
[[Variables]]
    TVN:     0.52254353 +/- 0.04203620 (8.04%) (init = 0.2)
    RVN:     0.45039796 +/- 0.00364906 (0.81%) (init = 0.5)
    RSOLOP:  0.07975519 +/- 3.23101609 (4051.17%) (init = 0.11)
    RSOLON:  0.21900602 +/- 1.30159136 (594.32%) (init = 0.225)
[[Correlations]] (unreported correlations are < 0.100)
    C(RVN, RSOLON)    =  0.941
    C(TVN, RSOLON)    = -0.829
    C(RVN, RSOLOP)    = -0.802
    C(RSOLOP, RSOLON) = -0.762
    C(TVN, RVN)       = -0.744
    C(TVN, RSOLOP)    =  0.289
\end{Verbatim}

\item Anote os valores dos parâmetros calibrados. Para mais detalhes a respeito da estatística do método de otimização de parâmetros aqui utilizado veja a seção \textit{Goodness-of-Fit Statistics} em \url{https://lmfit.github.io/lmfit-py/fitting.html}

\end{enumerate}

Obs.: O programa callSiB2pymodule.py em em \textbf{srcsib2model}/SiB2pymod/RadiativeTransModule, é um exemplo de como o sib2pymod do módulo de radiação deve ser executado no ambiente Python. 

\section{Calibração do Módulo de Momentum}

Aqui a calibração possui duas etapas.

\subsection{Determinação dos parâmetros aerodinâmicos a serem calibrados conforme a variação do índice de área foliar no tempo com uso da derive\_trans}
\label{zlt_aero_ts}

\begin{enumerate}

\item Obtenha o código em \textbf{srcsib2model}/SiB2pymod/MomentumModule/zlt\_aero\_ts

\item Defina os valores dos parâmetros ``zs'', ``zc'', ``leafw'' e ``leafl'' em ``derive\_trans.f95'', conforme as características do bioma.
\item  Compile e gere o módulo de Python
\begin{Verbatim}[breaklines=true]
f2py3.7 --fcompiler=gnu95 -c *.f95 -m sib2pymod
\end{Verbatim}

\item Obtenha os arquivos de entrada do SiB2: arquivo ``data2'' e o arquivo ``data1''.
  
\item Execute o programa ``callSiB2pymodule.py''.
\begin{Verbatim}[breaklines=true]
python3.7 callSiB2pymodule.py
\end{Verbatim}

\item Note que o arquivo ``zlt\_aero\_ts.dat'' foi gerado, contendo o conjunto de parâmetros aerodinâmicos para cada passo de tempo. 
  
\end{enumerate}

\subsection{Calibração dos parâmetros aerodinâmicos}
\label{aerocal}

\begin{enumerate}
\item Obtenha o código do módulo de momentum em \textbf{srcsib2model}/SiB2pymod/MomentumModule. 
\item  Compile e gere o módulo de Python
\begin{Verbatim}[breaklines=true]
f2py3.7 --fcompiler=gnu95 -c *.f95 -m sib2pymod
\end{Verbatim}
observe que um arquivo com nome similar à ``sib2pymod.cpython-37m-x86\_64-linux-gnu.so'' deve ser gerado, que é o módulo de Python 3. 

\item Obtenha os arquivos de entrada do SiB2: arquivo ``data2'' e o arquivo ``data1'' de parâmetros, porém, agora o arquivo ``data1'' deve ser editado para que contenha os valores dos parâmetros calibrados do módulo de radiação.

\item Obtenha o arquivo ``data3.csv'' com os dados observados que serão comparados com os valores calculados pelo SiB2 no processo de otimização de parâmetros. 

\item Copie o arquivo ``zlt\_aero\_ts.dat'' gerado em \ref{zlt_aero_ts} para o mesmo diretório do sib2pymod, ``data1'', ``data2'', ``data3.csv''.


\item Obtenha o programa ``calibraSiB2\_momentum\_leastsq.py'' para uso do método \textit{Levenberg-Marquardt} ou ``calibraSiB2\_momentum\_brute.py'' para uso do método \textit{brute} em \textbf{srcLCB}/calibracaoSiB2/momentum.

  
\item Execute o programa ``calibraSiB2\_momentum\_leastsq.py''
\begin{Verbatim}[breaklines=true]
python3.7 calibraSiB2_momentum_leastsq.py
\end{Verbatim}
ou o programa ``calibraSiB2\_momentum\_brute.py''.
\begin{Verbatim}[breaklines=true]
python3.7 calibraSiB2_momentum_brute.py
\end{Verbatim}
  
\item A saída deve ter a seguinte forma:

\begin{Verbatim}[breaklines=true]
[[Fit Statistics]]
    # fitting method   = leastsq
    # function evals   = 85
    # data points      = 732
    # variables        = 9
    chi-square         = 30.6064980
    reduced chi-square = 0.04233264
    Akaike info crit   = -2305.78390
    Bayesian info crit = -2264.42188
[[Variables]]
    ha:     23.8058861 +/- 0.56932611 (2.39%) (init = 23.53)
    z0d:    1.89174756 +/- 0.05014510 (2.65%) (init = 1.459)
    dd:     25.9954341 +/- 0.22468437 (0.86%) (init = 26.08)
    g2:     0.68042782 +/- 0.06066055 (8.92%) (init = 0.737)
    g3:     0.62291820 +/- 0.02801823 (4.50%) (init = 0.737)
    cc1:    10.3750000 +/- 1.8295e-14 (0.00%) (init = 10.375)
    cc2:    3324.78806 +/- 241.847705 (7.27%) (init = 2808.157)
    corb1:  13.1139182 +/- 0.65147631 (4.97%) (init = 12.643)
    corb2:  322.431000 +/- 2.4962e-13 (0.00%) (init = 322.431)
[[Correlations]] (unreported correlations are < 0.100)
    C(cc1, corb2)   = -1.000
    C(dd, g2)       = -0.990
    C(g3, cc2)      = -0.971
    C(ha, dd)       = -0.888
    C(ha, g2)       =  0.882
    C(ha, corb1)    = -0.845
    C(g2, corb2)    =  0.637
    C(g2, cc1)      = -0.634
    C(dd, corb2)    = -0.632
    C(dd, cc1)      =  0.626
    C(dd, corb1)    =  0.600
    C(g2, corb1)    = -0.577
    C(ha, corb2)    =  0.414
    C(ha, cc1)      = -0.408
    C(cc2, corb1)   = -0.344
    C(g3, corb1)    =  0.312
    C(z0d, g2)      = -0.245
    C(z0d, corb1)   =  0.230
    C(z0d, cc1)     =  0.220
    C(z0d, corb2)   = -0.214
    C(ha, cc2)      =  0.185
    C(dd, cc2)      = -0.166
    C(z0d, dd)      =  0.165
    C(g3, corb2)    = -0.153
    C(g3, cc1)      =  0.146
    C(corb1, corb2) = -0.142
    C(cc1, corb1)   =  0.132
    C(cc2, corb2)   =  0.129
    C(cc1, cc2)     = -0.121
    C(ha, g3)       = -0.111
    C(dd, g3)       =  0.105
    C(g2, cc2)      =  0.104
\end{Verbatim}

\item Observe a criação do arquivo ``params\_calibrado.dat'' com os valores dos parâmetros calibrados que deverá ser carregado nos módulos subsequentes.
  
\end{enumerate}

\section{Calibração do Módulo de Umidade do Solo}

\begin{enumerate}
\item Obtenha o código do módulo de umidade do solo em \textbf{srcsib2model}/SiB2pymod/SoilMoistureModule. 
\item  Compile e gere o módulo de Python
\begin{Verbatim}[breaklines=true]
f2py3.7 --fcompiler=gnu95 -c *.f95 -m sib2pymod
\end{Verbatim}
observe que um arquivo com nome similar à ``sib2pymod.cpython-37m-x86\_64-linux-gnu.so'' deve ser gerado, que é o módulo de Python 3. 

\item Obtenha os arquivos de entrada do SiB2: arquivo ``data2'' e o arquivo ``data1''.

\item Obtenha o arquivo ``data3.csv'' com os dados observados que serão comparados com os valores calculados pelo SiB2 no processo de otimização de parâmetros.

\item Obtenha o arquivo ``params\_calibrado.dat'' gerado em \ref{aerocal}. Nesta etapa, não é necessário editar o arquivo ``data1'', pois os parâmetros aerodinâmicos calibrados são carregados pelo programa ``load\_aeropars.f95'' a cada passo de tempo. 

\item Obtenha o programa ``calibraSiB2\_leastsq.py'' para uso do método \textit{Levenberg-Marquardt} ou ``calibraSiB2\_brute.py'' para uso do método \textit{brute} em \textbf{srcLCB}/calibracaoSiB2/umidade.
  
\item Execute o programa ``calibraSiB2\_leastsq.py''
\begin{Verbatim}[breaklines=true]
python3.7 calibraSiB2_leastsq.py
\end{Verbatim}
ou o programa ``calibraSiB2\_brute.py''.
\begin{Verbatim}[breaklines=true]
python3.7 calibraSiB2_brute.py
\end{Verbatim}

\item Observe que a saída deve ter a seguinte forma:

\begin{Verbatim}[breaklines=true]
[[Fit Statistics]]
    # fitting method   = leastsq
    # function evals   = 46
    # data points      = 744
    # variables        = 4
    chi-square         = 247.572512
    reduced chi-square = 0.33455745
    Akaike info crit   = -810.651114
    Bayesian info crit = -792.202950
[[Variables]]
    bee1:    6.13789646 +/- 19.0310266 (310.06%) (init = 7.12)
    phsat1: -0.01000158 +/- 0.00693809 (69.37%) (init = -0.2)
    satco1:  9.3885e-05 +/- 5.8644e-04 (624.64%) (init = 5e-06)
    poros1:  0.30878321 +/- 0.01715190 (5.55%) (init = 0.515)
[[Correlations]] (unreported correlations are < 0.100)
    C(phsat1, satco1) =  0.974
    C(bee1, phsat1)   = -0.377
    C(bee1, poros1)   =  0.325
    C(bee1, satco1)   = -0.156
\end{Verbatim}

\item Anote os valores dos parâmetros calibrados.
\end{enumerate}

\section{Calibração do Módulo de Carbono e Água}

\begin{enumerate}
\item Obtenha o código do módulo de carbono e água em \textbf{srcsib2model}/SiB2pymod/CarbonWaterModule. 
\item  Compile e gere o módulo de Python
\begin{Verbatim}[breaklines=true]
f2py3.7 --fcompiler=gnu95 -c *.f95 -m sib2pymod
\end{Verbatim}
observe que um arquivo com nome similar à ``sib2pymod.cpython-37m-x86\_64-linux-gnu.so'' deve ser gerado, que é o módulo de Python 3. 

\item Obtenha os arquivos de entrada do SiB2: arquivo ``data2'' e o arquivo ``data1''.

\item Obtenha o arquivo ``data3.csv'' com os dados observados que serão comparados com os valores calculados pelo SiB2 no processo de otimização de parâmetros.

\item Obtenha o arquivo ``params\_calibrado.dat'' gerado em \ref{aerocal}. Agora, além dos parâmetros aerodinâmicos serem carregados pelo programa ``load\_aeropars.f95'', é necessário editar o arquivo ``data1'' com os valores dos parâmetros obtidos no módulo de calibração de umidade do solo.
x
\item Obtenha o programa ``calibraSiB2\_leastsq.py'' para uso do método \textit{Levenberg-Marquardt} ou ``calibraSiB2\_brute.py'' para uso do método \textit{brute} em \textbf{srcLCB}/calibracaoSiB2/carbonoagua.
  
\item Execute o programa ``calibraSiB2\_leastsq.py''
\begin{Verbatim}[breaklines=true]
python3.7 calibraSiB2_leastsq.py
\end{Verbatim}
ou o programa ``calibraSiB2\_brute.py''.
\begin{Verbatim}[breaklines=true]
python3.7 calibraSiB2_brute.py
\end{Verbatim}

\item Observe que a saída deve ter a seguinte forma:

\begin{Verbatim}[breaklines=true]
[[Fit Statistics]]
    # fitting method   = leastsq
    # function evals   = 64
    # data points      = 667
    # variables        = 4
    chi-square         = 106689.129
    reduced chi-square = 160.918747
    Akaike info crit   = 3392.94796
    Bayesian info crit = 3410.95912
[[Variables]]
    gradm:     20.9092373 +/- 2.09814850 (10.03%) (init = 16)
    gmudmu:    0.72108549 +/- 0.04779871 (6.63%) (init = 1)
    greeness:  0.99993604 +/- 8.8220e-06 (0.00%) (init = 0.99)
    vmax:      108.073123 +/- 14.0153431 (12.97%) (init = 105)
[[Correlations]] (unreported correlations are < 0.100)
    C(gradm, vmax)     = -0.797
    C(gmudmu, vmax)    = -0.404
    C(gradm, gmudmu)   = -0.231
    C(greeness, vmax)  =  0.186
    C(gradm, greeness) = -0.183
\end{Verbatim}
\end{enumerate}

\section{Execução do SiB2 calibrado}

\begin{enumerate}
\item Obtenha os arquivos de entrada do SiB2 calibrado: arquivo ``data2'', arquivo ``data1'' com os respectivos parâmetros calibrados e o arquivo ``params\_calibrado.dat'' obtido em \ref{aerocal}.
\item Obtenha o código do SiB2 em \textbf{srcsib2model}/SiB2f95momentum, compile e gere o executável:
\begin{Verbatim}[breaklines=true]
gfortran comsibc.f95 pardif.f95 load_aeropars.f95 sib2x.f95 Sib2xa.f95 Sib2xb.f95 -o sib2run
\end{Verbatim}

\item Execute
\begin{Verbatim}[breaklines=true]
./sib2run
\end{Verbatim}
  
\item Observe que os arquivo ``sib2dt.dat'' com as variáveis calculadas do SiB2 calibrado foi criado.
\end{enumerate}


\vspace{\baselineskip}
\chapter{Calibração de modelo de balanço de água para pequenas bacias}
\vspace{\baselineskip}

O modelo de balanço de água descrito em \citeonline{vandewiele1992}, foi reproduzido no ambiente python. Nesta formulação, os parâmetros do  modelo são obtidos por um processo numérico de minimização de erros com base em dados observacionais de evapotranspiração potencial, precipitação e vazão. Ao invés do uso do pacote computacional ``VA05A'' foi utilizado os métodos ``brute'' e ``Levenberg-Marquardt'' do LMFI \cite{lmfit} para obtenção dos parâmetros do modelo de balanço de água.

O formulação numérica do modelo está no repositório \textbf{hidromodel}, nos códigos ``balagua\_ugrhi\_brute.py'' e ``balagua\_ugrhi\_leastsq.py'' que correspondem ao mesmo modelo de balanço de água de \citeonline{vandewiele1992} já acoplado com o método de obtenção de parâmetros ``brute'' e ``Levenberg-Marquardt'' respectivamente.   

\section{Obtendo os parâmetros do modelo de balanço de água}

Os parâmetros do modelo são obtidos com base na série temporal mensal de dados observacionais de evapotranspiração potencial (etp), precipitação (p) e vazão (q). Aqui, a evapotranspiração potencial foi obtida da \textit{Climatic Research Unit (University of East Anglia) and Met Office} (\url{http://www.cru.uea.ac.uk/}) ou da \textit{Texas A\&M University} \url{https://utexas.app.box.com/v/xavier-etal-ijoc-data} e os dados de vazão e precipitação, obtidos das UGRHI (Unidade de Gerenciamento de Recursos Hídricos de São Paulo) e estações meteorológicas do INMET (Instituto Nacional de Meteorologia). Porém essa combinação pode variar conforme cada bacia hidrográfica e método de obtenção da evapotranspiração potencial.

O código fonte ``ts\_to\_hidromodel\_ugrhi\_cru.py'' em \textbf{srcLCB}/utils vem sendo utilizado para criar as séries de dados observacionais de entrada para o modelamento das bacias hidrográficas que pertencem as UGRHI do estado de São Paulo no LCB e poderá auxiliar em futuras construções.

Após a construção da série de dados de etp, p e q, executa-se
\begin{Verbatim}[breaklines=true]
python3.7 balagua_ugrhi_leastsq.py
\end{Verbatim}
ou
\begin{Verbatim}[breaklines=true]
python3.7 balagua_ugrhi_brute.py
\end{Verbatim}
conforme o método de otimização de parâmetros ``Levenberg-Marquardt'' ou ``brute'', o qual deseja-se.  


% \vspace{\baselineskip}
% \chapter{Utilitários para o LCB: repositório srcLCB}
% \vspace{\baselineskip}
% \section{Usando o GNU Data Language - GDL}
% \vspace{\baselineskip}

% Baixe a ultima versão em https://github.com/gnudatalanguage/gdl
 
% \begin{Verbatim}[breaklines=true]
% mkdir gdl-build
% cd gdl-build
% cmake -DLIBPROJ4=YES
% -DLIBPROJ4DIR='/home/user/GDL/libs/proj-4.9.3_bin' -DPYTHON_MODULE=YES
% ../gdl-master cmake -DLIBPROJ4=YES -DLIBPROJ4DIR='/home/evandro/pacotes/GDL/libs/proj-4.9.3_bin'
% -DPYTHON_MODULE=YES -DPYTHON=YES ../gdl-master
% \end{Verbatim}

% %\vspace{\baselineskip}


% \begin{Verbatim}[breaklines=true]
%     m1 = 500  # estimativa de m1 inicial
%     r2 = 0.
%     s2 = 0.
%     n2 = 0.
%     d2 = 0
%     m2 = 0
   
%     for kount in range(0, m_func):
%         """
%         Modelo de balanco de agua
%         r2 => evapotranpiracao real
%         s2 => escoamento lento
%         n2 => precipitacao ativa
%         f2 => escoamento rapido
%         d2 => vazao com filtro
%         """
%         r2 = min(
%             etp[kount]*(1.-a1**((p2[kount]+max(m1, 0.))/etp[kount])),
%             (p2[kount]+max(m1, 0.))
%         )
%         s2 = a2*(max(m1, 0.)**a22)
%         n2 = p2[kount]-etp[kount]*(1-np.exp(-p2[kount]/etp[kount]))
%         f2 = a3*max(m1, 0.)*n2
%         d2 = s2+f2
%         m2 = m1 + p2[kount] - r2 - d2
%         modeloerro[kount] = np.sqrt(q2[kount]) - np.sqrt(d2)  # Wanderwiele

%         m1 = m2
% \end{Verbatim}




\endgroup
\renewcommand{\bibname}{REFER\^ENCIAS}
\bibliography{referencias}

\end{document}